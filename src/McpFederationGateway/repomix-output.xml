This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.mcp/
  server.json
Interfaces/
  IAggregationService.cs
  IConfigurationService.cs
  IMcpClientFactory.cs
  IMicroAgentChatClient.cs
  IRouterService.cs
Models/
  AppJsonContext.cs
  ChatMessage.cs
  ChatOptions.cs
  ChatResponse.cs
  ChatRole.cs
  GatewayConfig.cs
  McpServerConfig.cs
  MicroAgentChatRequest.cs
SCRIPTS/
  run-repomix.sh
Services/
  AggregationService.cs
  ConfigurationService.cs
  McpClientFactory.cs
  RouterService.cs
  SamplingMicroAgentChatClient.cs
McpFederationGateway.csproj
Program.cs
SourceGenerationContext.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".mcp/server.json">
{
  "$schema": "https://static.modelcontextprotocol.io/schemas/2025-10-17/server.schema.json",
  "description": "MicroAgents MCP Federation Gateway - A reverse proxy and aggregator for MCP servers",
  "name": "MicroAgentsNet/McpFederationGateway",
  "version": "0.1.0-preview",
  "packages": [
    {
      "registryType": "nuget",
      "identifier": "MicroAgents.McpFederationGateway",
      "version": "0.1.0-preview",
      "transport": {
        "type": "stdio"
      },
      "packageArguments": [],
      "environmentVariables": []
    }
  ],
  "repository": {
    "url": "https://github.com/MicroAgentsNet/McpFederationGateway",
    "source": "github"
  }
}
</file>

<file path="Interfaces/IAggregationService.cs">
using ModelContextProtocol.Protocol;

namespace McpFederationGateway.Interfaces;

public interface IAggregationService
{
    Task<IEnumerable<Tool>> GetToolsAsync();
}
</file>

<file path="Interfaces/IConfigurationService.cs">
using McpFederationGateway.Models;

namespace McpFederationGateway.Interfaces;

public interface IConfigurationService
{
    Task<GatewayConfig> GetConfigAsync();
}
</file>

<file path="Interfaces/IMcpClientFactory.cs">
using ModelContextProtocol.Client;
using McpFederationGateway.Models;

namespace McpFederationGateway.Interfaces;

public interface IMcpClientFactory
{
    Task<McpClient> GetClientAsync(McpServerConfig config);
}
</file>

<file path="Interfaces/IMicroAgentChatClient.cs">
using McpFederationGateway.Models;
namespace McpFederationGateway.Interfaces;

/// <summary>
/// Unified interface for chat/LLM interactions.
/// </summary>
public interface IMicroAgentChatClient
{
    Task<ChatResponse> GetResponseAsync(MicroAgentChatRequest request, CancellationToken cancellationToken = default);
}
</file>

<file path="Interfaces/IRouterService.cs">
using ModelContextProtocol.Protocol;

namespace McpFederationGateway.Interfaces;

public interface IRouterService
{
    Task<CallToolResult> CallToolAsync(string fullName, IDictionary<string, object?> arguments, CancellationToken cancellationToken);
}
</file>

<file path="Models/AppJsonContext.cs">
using System.Text.Json.Serialization;
using System.Text.Json;
using System.Collections.Generic;

namespace McpFederationGateway.Models;

[JsonSerializable(typeof(GatewayConfig))]
[JsonSerializable(typeof(List<McpServerConfig>))]
[JsonSerializable(typeof(McpServerConfig))]
[JsonSerializable(typeof(LlmConfig))]
[JsonSerializable(typeof(McpTransportType))]
[JsonSerializable(typeof(McpOperationMode))]
[JsonSerializable(typeof(ChatMessage))]
[JsonSerializable(typeof(List<ChatMessage>))]
[JsonSerializable(typeof(ChatOptions))]
[JsonSerializable(typeof(ChatResponse))]
[JsonSerializable(typeof(ChatRole))]
[JsonSerializable(typeof(MicroAgentChatRequest))]
[JsonSerializable(typeof(ChatRequestVendorExtensions))]
[JsonSerializable(typeof(AnthropicExtensions))]
[JsonSerializable(typeof(GoogleExtensions))]
[JsonSerializable(typeof(JsonElement))]
public partial class AppJsonContext : JsonSerializerContext
{
}
</file>

<file path="Models/ChatMessage.cs">
using System.Diagnostics.CodeAnalysis;

namespace McpFederationGateway.Models;

/// <summary>
/// Represents a message in a chat conversation.
/// </summary>
public record ChatMessage
{
    /// <summary>
    /// Creates a new ChatMessage with User role by default.
    /// </summary>
    [SetsRequiredMembers]
    public ChatMessage()
    {
        Role = ChatRole.User;
        Content = null;
    }

    /// <summary>
    /// Creates a new ChatMessage with the specified role and content.
    /// </summary>
    /// <param name="role">The role of the message sender.</param>
    /// <param name="content">The text content of the message.</param>
    [SetsRequiredMembers]
    public ChatMessage(ChatRole role, string? content)
    {
        Role = role;
        Content = content;
    }

    /// <summary>
    /// The role of the message sender (System, User, or Assistant).
    /// </summary>
    public required ChatRole Role { get; init; }

    /// <summary>
    /// The text content of the message.
    /// </summary>
    public required string? Content { get; init; }

    /// <summary>
    /// Optional name of the sender (for multi-user chats).
    /// </summary>
    public string? Name { get; init; }
}
</file>

<file path="Models/ChatOptions.cs">
namespace McpFederationGateway.Models;

/// <summary>
/// Options for controlling chat/LLM request behavior.
/// </summary>
public record ChatOptions
{
    /// <summary>
    /// Maximum number of tokens to generate in the response.
    /// </summary>
    public int? MaxOutputTokens { get; init; }

    /// <summary>
    /// Temperature for randomness in responses (0.0 to 2.0).
    /// Lower values make output more focused and deterministic.
    /// </summary>
    public float? Temperature { get; init; }

    /// <summary>
    /// Model ID to use for the request (e.g., "gpt-4", "claude-3-sonnet").
    /// </summary>
    public string? ModelId { get; init; }

    /// <summary>
    /// Top P sampling parameter (0.0 to 1.0).
    /// Controls diversity via nucleus sampling.
    /// </summary>
    public float? TopP { get; init; }
}
</file>

<file path="Models/ChatResponse.cs">
namespace McpFederationGateway.Models;

/// <summary>
/// Response from a chat/LLM invocation.
/// </summary>
public record ChatResponse
{
    /// <summary>
    /// The text content of the response.
    /// </summary>
    public string? Text { get; init; }

    /// <summary>
    /// The model that generated the response.
    /// </summary>
    public string? ModelId { get; init; }

    /// <summary>
    /// The finish reason (e.g., "stop", "length", "tool_calls").
    /// </summary>
    public string? FinishReason { get; init; }
}
</file>

<file path="Models/ChatRole.cs">
namespace McpFederationGateway.Models;

/// <summary>
/// The role of the message in a chat conversation.
/// </summary>
public enum ChatRole
{
    /// <summary>
    /// System message providing instructions or context.
    /// </summary>
    System,
    
    /// <summary>
    /// Message from the user/human.
    /// </summary>
    User,
    
    /// <summary>
    /// Message from the AI assistant.
    /// </summary>
    Assistant
}
</file>

<file path="Models/GatewayConfig.cs">
namespace McpFederationGateway.Models;

public record GatewayConfig
{
    public List<McpServerConfig> Servers { get; init; } = new();
    public LlmConfig? Llm { get; init; }
}

public record LlmConfig
{
    public string? DefaultModel { get; init; }
    public double? Temperature { get; init; }
}
</file>

<file path="Models/McpServerConfig.cs">
using System.Text.Json.Serialization;

namespace McpFederationGateway.Models;

/// <summary>
///     The transport type used to communicate with an MCP server.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<McpTransportType>))]
public enum McpTransportType
{
    /// <summary>
    ///     Standard input/output protocol.
    /// </summary>
    Stdio,

    /// <summary>
    ///     HTTP with Server-Sent Events (SSE).
    /// </summary>
    Http
}

/// <summary>
///     Operational mode for how tools from the MCP server are exposed.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<McpOperationMode>))]
public enum McpOperationMode
{
    /// <summary>
    ///     Directly exposes tools from the MCP server with a prefix.
    /// </summary>
    Direct,

    /// <summary>
    ///     Hides tools from the main list, allowing access via meta-tools only.
    /// </summary>
    Federated
}

public record McpServerConfig
{
    public required string Name { get; init; }
    public McpTransportType Transport { get; init; } = McpTransportType.Stdio;
    public McpOperationMode Mode { get; init; } = McpOperationMode.Direct;
    public string? Command { get; init; }
    public string[]? Arguments { get; init; }
    public string? Url { get; init; }
}
</file>

<file path="Models/MicroAgentChatRequest.cs">
using System.Text.Json.Serialization;

namespace McpFederationGateway.Models;

/// <summary>
///     Chat outbound features supported only by a single/few providers with no shared equivalent.
/// </summary>
public record ChatRequestVendorExtensions
{
    public AnthropicExtensions? Anthropic { get; init; }
    public GoogleExtensions? Google { get; init; }
}

public record AnthropicExtensions
{
    public string? Thinking { get; init; }
}

public record GoogleExtensions
{
    public bool? UseSearch { get; init; }
}

public record MicroAgentChatRequest
{
    public IList<ChatMessage> Messages { get; init; } = new List<ChatMessage>();
    public ChatOptions? Options { get; init; }
    public ChatRequestVendorExtensions? VendorExtensions { get; init; }
}
</file>

<file path="SCRIPTS/run-repomix.sh">
#!/bin/bash
# Run repomix-mcp and suppress stderr to avoid confusing the MCP client
# We assume "Repomix MCP server running on stdio" is printed to stderr.
# Suppressing stderr entirely might hide errors, but it's necessary if StdioClientTransport is strict or if piping issues occur.

# Ensure we use npx
# Try to silence stderr
exec npx -y repomix-mcp 2>/dev/null
</file>

<file path="Services/AggregationService.cs">
using McpFederationGateway.Interfaces;
using ModelContextProtocol.Protocol;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using McpFederationGateway.Models;

namespace McpFederationGateway.Services;

public class AggregationService : IAggregationService
{
    private readonly IConfigurationService _configService;
    private readonly IMcpClientFactory _clientFactory;
    private readonly ILogger<AggregationService> _logger;

    public AggregationService(IConfigurationService configService, IMcpClientFactory clientFactory, ILogger<AggregationService> logger)
    {
        _configService = configService;
        _clientFactory = clientFactory;
        _logger = logger;
    }

    public async Task<IEnumerable<Tool>> GetToolsAsync()
    {
        var config = await _configService.GetConfigAsync();
        var allTools = new List<Tool>();

        foreach (var serverConfig in config.Servers)
        {
            var serverName = serverConfig.Name;
            try
            {
                if (serverConfig.Mode == McpOperationMode.Federated)
                {
                    continue;
                }

                var client = await _clientFactory.GetClientAsync(serverConfig);
                var tools = await client.ListToolsAsync();
                
                foreach (var mcpTool in tools)
                {
                    var tool = mcpTool.ProtocolTool;
                    allTools.Add(new Tool
                    {
                        Name = $"{serverName}_{tool.Name}",
                        Description = $"[{serverName}] {tool.Description}",
                        InputSchema = tool.InputSchema
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to aggregate tools from server {ServerName}", serverName);
            }
        }

        // Add Federated Meta-Tools
        allTools.Add(new Tool
        {
            Name = "how_to_use",
            Description = "Provides documentation, summaries, and usage guides for a specific federated MCP server.",
            InputSchema = JsonSerializer.Deserialize(@"{
                ""type"": ""object"",
                ""properties"": {
                    ""server_name"": {
                        ""type"": ""string"",
                        ""description"": ""The name of the federated MCP server to get documentation for""
                    }
                },
                ""required"": []
            }", AppJsonContext.Default.JsonElement)
        });

        allTools.Add(new Tool
        {
            Name = "call",
            Description = "Calls a tool on a specific federated MCP server.",
            InputSchema = JsonSerializer.Deserialize(@"{
                ""type"": ""object"",
                ""properties"": {
                    ""server_name"": {
                        ""type"": ""string"",
                        ""description"": ""The federated server name""
                    },
                    ""tool_name"": {
                        ""type"": ""string"",
                        ""description"": ""The target tool name on the server""
                    },
                    ""arguments"": {
                        ""type"": ""object"",
                        ""description"": ""Arguments for the tool""
                    }
                },
                ""required"": [""server_name"", ""tool_name""]
            }", AppJsonContext.Default.JsonElement)
        });

        return allTools;
    }
}
</file>

<file path="Services/ConfigurationService.cs">
using McpFederationGateway.Interfaces;
using McpFederationGateway.Models;
using System.Text.Json;

namespace McpFederationGateway.Services;

public class ConfigurationService : IConfigurationService
{
    private const string ConfigEnvVar = "MICROAGENTS_CONFIG";
    private readonly string _userConfigPath;
    private readonly JsonSerializerOptions _jsonOptions;
    private readonly AppJsonContext _jsonContext;

    public ConfigurationService()
    {
        var envPath = Environment.GetEnvironmentVariable(ConfigEnvVar);
        if (!string.IsNullOrEmpty(envPath))
        {
            _userConfigPath = envPath;
        }
        else
        {
            var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            _userConfigPath = Path.Combine(home, ".microagents", "config.json");
        }

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
            AllowTrailingCommas = true
        };
        // Bind context to options
        _jsonOptions.TypeInfoResolver = AppJsonContext.Default; 
        // Actually, if we use the constructor pattern:
        _jsonContext = new AppJsonContext(_jsonOptions);
    }

    public async Task<GatewayConfig> GetConfigAsync()
    {
        if (!File.Exists(_userConfigPath))
        {
            return new GatewayConfig();
        }

        try
        {
            using var stream = File.OpenRead(_userConfigPath);
            var config = await JsonSerializer.DeserializeAsync(stream, _jsonContext.GatewayConfig);
            return config ?? new GatewayConfig();
        }
        catch (Exception)
        {
            // Fallback to empty config on error
            // In production, we might want to log this
            return new GatewayConfig();
        }
    }
}
</file>

<file path="Services/McpClientFactory.cs">
using ModelContextProtocol.Client;
using ModelContextProtocol.Protocol;
using McpFederationGateway.Interfaces;
using McpFederationGateway.Models;
using Microsoft.Extensions.Logging;


namespace McpFederationGateway.Services;

public class McpClientFactory : IMcpClientFactory
{
    private readonly Dictionary<string, McpClient> _clients = new();
    private readonly ILogger<McpClientFactory> _logger;

    public McpClientFactory(ILogger<McpClientFactory> logger)
    {
        _logger = logger;
    }

    public async Task<McpClient> GetClientAsync(McpServerConfig config)
    {
        _logger.LogInformation("GetClientAsync called for server: {ServerName}, Transport: {Transport}", config.Name, config.Transport);

        if (_clients.TryGetValue(config.Name, out var client))
        {
            _logger.LogDebug("Returning cached client for {ServerName}", config.Name);
            return client;
        }

        IClientTransport transport = config.Transport switch
        {
            McpTransportType.Stdio => new StdioClientTransport(new StdioClientTransportOptions
            {
                Name = config.Name,
                Command = config.Command!,
                Arguments = config.Arguments ?? Array.Empty<string>()
            }),
            McpTransportType.Http => new HttpClientTransport(new HttpClientTransportOptions
            {
                Name = config.Name,
                Endpoint = new Uri(config.Url!)
            }),
            _ => throw new NotSupportedException($"Transport {config.Transport} is not supported.")
        };

        _logger.LogInformation("Creating new client for {ServerName}...", config.Name);
        
        var mcpClient = await McpClient.CreateAsync(transport, new McpClientOptions 
        { 
            ClientInfo = new Implementation { Name = "McpFederationGateway", Version = "1.0.0" }
        });

        _logger.LogInformation("Client created (handshake complete) for {ServerName}", config.Name);
        _clients[config.Name] = mcpClient;
        return mcpClient;
    }
}
</file>

<file path="Services/RouterService.cs">
using McpFederationGateway.Interfaces;
using ModelContextProtocol.Protocol;
using McpFederationGateway.Models;
using Microsoft.Extensions.Logging;
using System.Text.Json;

namespace McpFederationGateway.Services;

public class RouterService : IRouterService
{
    private readonly IConfigurationService _configService;
    private readonly IMcpClientFactory _clientFactory;
    private readonly IMicroAgentChatClient _chatClient;
    private readonly ILogger<RouterService> _logger;

    public RouterService(IConfigurationService configService, IMcpClientFactory clientFactory, IMicroAgentChatClient chatClient, ILogger<RouterService> logger)
    {
        _configService = configService;
        _clientFactory = clientFactory;
        _chatClient = chatClient;
        _logger = logger;
    }

    public async Task<CallToolResult> CallToolAsync(string fullName, IDictionary<string, object?> arguments, CancellationToken cancellationToken)
    {
        _logger.LogInformation("RouterService received CallTool: {ToolName}", fullName);
        if (arguments != null)
        {
            foreach (var kvp in arguments)
            {
                _logger.LogInformation("Arg: {Key}, Type: {Type}, Value: {Value}", kvp.Key, kvp.Value?.GetType().Name ?? "null", kvp.Value);
            }
        }
        if (fullName == "call")
        {
            if (!arguments.TryGetValue("server_name", out var serverObj) || serverObj is not string serverName)
                throw new ArgumentException("Argument 'server_name' is required for 'call' tool");

            if (!arguments.TryGetValue("tool_name", out var toolObj) || toolObj is not string toolName)
                throw new ArgumentException("Argument 'tool_name' is required for 'call' tool");

            var actualArgs = arguments.TryGetValue("arguments", out var argsObj) && argsObj is IDictionary<string, object?> d ? d : new Dictionary<string, object?>();

             return await InvokeDirectAsync(serverName, toolName, actualArgs, cancellationToken);
        }

        if (fullName == "how_to_use")
        {
            string? targetName = null;
            if (arguments.TryGetValue("server_name", out var targetObj))
            {
                if (targetObj is string s) targetName = s;
                else if (targetObj is JsonElement je && je.ValueKind == JsonValueKind.String) targetName = je.GetString();
            }

            string? topic = null;
            if (arguments.TryGetValue("topic", out var topicObj))
            {
                if (topicObj is string s) topic = s;
                else if (topicObj is JsonElement je && je.ValueKind == JsonValueKind.String) topic = je.GetString();
            }

            if (string.IsNullOrEmpty(targetName))
            {
                return await GenerateGlobalDocumentationAsync(cancellationToken);
            }

            return await GenerateDocumentationAsync(targetName, topic, cancellationToken);
        }

        // Direct prefixed tool handling. Format: serverName_toolName
        var firstUnderscore = fullName.IndexOf('_');
        if (firstUnderscore > 0)
        {
            var serverName = fullName.Substring(0, firstUnderscore);
            var toolName = fullName.Substring(firstUnderscore + 1);
            return await InvokeDirectAsync(serverName, toolName, arguments, cancellationToken);
        }

        throw new KeyNotFoundException($"Tool {fullName} not found.");
    }

    private async Task<CallToolResult> InvokeDirectAsync(string serverName, string toolName, IDictionary<string, object?> arguments, CancellationToken cancellationToken)
    {
        var config = await _configService.GetConfigAsync();
        var serverConfig = config.Servers.FirstOrDefault(s => s.Name == serverName)
            ?? throw new KeyNotFoundException($"Server {serverName} not found in configuration.");

        var client = await _clientFactory.GetClientAsync(serverConfig);
        var readOnlyArgs = arguments as IReadOnlyDictionary<string, object?> ?? new Dictionary<string, object?>(arguments);
        return await client.CallToolAsync(toolName, readOnlyArgs);
    }

    private async Task<CallToolResult> GenerateDocumentationAsync(string serverName, string? topic, CancellationToken cancellationToken)
    {
        var config = await _configService.GetConfigAsync();
        var serverConfig = config.Servers.FirstOrDefault(s => s.Name == serverName)
            ?? throw new KeyNotFoundException($"Server {serverName} not found in configuration.");

        var client = await _clientFactory.GetClientAsync(serverConfig);
        var tools = await client.ListToolsAsync(cancellationToken: cancellationToken);

        var toolSummaries = string.Join("\n", tools.Select(t => $"- {t.Name}: {t.Description}"));
        
        var prompt = $"""
            You are the MCP Federation Gateway. Provide a concise guide on how to use the MCP server '{serverName}'.
            
            Available tools in this server:
            {toolSummaries}
            
            {(topic != null ? $"Focus particularly on the topic: {topic}" : "")}
            
            Explain what this server does and give examples of when and how to call its tools.
            """;

        var response = await _chatClient.GetResponseAsync(new MicroAgentChatRequest
        {
            Messages = new List<ChatMessage> { new ChatMessage(ChatRole.User, prompt) },
            Options = new ChatOptions { MaxOutputTokens = 1000 }
        }, cancellationToken);

        return new CallToolResult
        {
            Content = new List<ContentBlock>
            {
                new TextContentBlock { Text = response.Text ?? "No documentation generated." }
            }
        };
    }

    private async Task<CallToolResult> GenerateGlobalDocumentationAsync(CancellationToken cancellationToken)
    {
        var config = await _configService.GetConfigAsync();
        var federatedServers = config.Servers
            .Where(s => s.Mode == McpOperationMode.Federated)
            .Select(s => s.Name)
            .ToList();

        var serverList = string.Join(", ", federatedServers.Select(s => $"'{s}'"));

        return new CallToolResult
        {
            Content = new List<ContentBlock>
            {
                new TextContentBlock 
                { 
                    Text = $"Global Discovery: This gateway federates multiple MCP servers. Available federated servers are: {serverList}. " +
                           "Use 'how_to_use' with 'server_name' parameter set to one of these names to get detailed documentation."
                }
            }
        };
    }
}
</file>

<file path="Services/SamplingMicroAgentChatClient.cs">
using McpFederationGateway.Interfaces;
using McpFederationGateway.Models;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.Server;
using ModelContextProtocol.Protocol;

namespace McpFederationGateway.Services;

/// <summary>
/// Chat client implementation using MCP Server's sampling capability.
/// Delegates the LLM generation to the connected MCP client (e.g., Claude Desktop, IDE).
/// </summary>
public class SamplingMicroAgentChatClient : IMicroAgentChatClient
{
    private readonly McpServer _server;
    private readonly IConfigurationService _configurationService;
    private readonly ILogger<SamplingMicroAgentChatClient> _logger;

    public SamplingMicroAgentChatClient(
        McpServer server, 
        IConfigurationService configurationService, 
        ILogger<SamplingMicroAgentChatClient> logger)
    {
        _server = server;
        _configurationService = configurationService;
        _logger = logger;
    }

    public async Task<ChatResponse> GetResponseAsync(MicroAgentChatRequest request, CancellationToken cancellationToken = default)
    {
        var config = await _configurationService.GetConfigAsync();
        
        var samplingMessages = new List<SamplingMessage>();
        string? systemPrompt = null;

        foreach (var message in request.Messages)
        {
            if (message.Role == ChatRole.System)
            {
                if (systemPrompt == null)
                    systemPrompt = message.Content;
                else
                    systemPrompt += "\n" + message.Content;
            }
            else
            {
                var role = message.Role switch
                {
                    ChatRole.User => Role.User,
                    ChatRole.Assistant => Role.Assistant,
                    _ => Role.User
                };

                var content = new TextContentBlock
                {
                    Text = message.Content ?? string.Empty
                };

                samplingMessages.Add(new SamplingMessage
                {
                    Role = role,
                    Content = new List<ContentBlock> { content }
                });
            }
        }

        var modelPreferences = new ModelPreferences
        {
            CostPriority = 0.5f, 
            SpeedPriority = 0.5f,
            IntelligencePriority = 0.5f
        };

        if (config.Llm?.DefaultModel != null)
        {
            modelPreferences.Hints = new List<ModelHint> { new ModelHint { Name = config.Llm.DefaultModel } };
        }
        
        if (!string.IsNullOrEmpty(request.Options?.ModelId))
        {
             modelPreferences.Hints = new List<ModelHint> { new ModelHint { Name = request.Options.ModelId } };
        }

        var createMessageRequest = new CreateMessageRequestParams
        {
            Messages = samplingMessages.ToArray(),
            SystemPrompt = systemPrompt,
            IncludeContext = ContextInclusion.ThisServer, 
            Temperature = (float?)((request.Options?.Temperature ?? config.Llm?.Temperature)),
            MaxTokens = (int)(request.Options?.MaxOutputTokens ?? 4096),
            ModelPreferences = modelPreferences
        };

        try
        {
            _logger.LogInformation("Requesting sampling from client...");
            
            var result = await _server.SampleAsync(createMessageRequest, cancellationToken);
            
            var sb = new System.Text.StringBuilder();
            if (result.Content != null)
            {
                foreach (var block in result.Content)
                {
                    if (block is TextContentBlock textBlock)
                    {
                        sb.Append(textBlock.Text);
                    }
                }
            }
            
            var responseText = sb.ToString();

            return new ChatResponse
            {
                Text = responseText,
                ModelId = result.Model,
                FinishReason = result.StopReason
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to sample message from client.");
            throw new InvalidOperationException("Failed to get response from MCP Client via Sampling.", ex);
        }
    }
}
</file>

<file path="McpFederationGateway.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <PublishAot>true</PublishAot>
    <InvariantGlobalization>true</InvariantGlobalization>

    <!-- Set up the NuGet package to be an MCP server -->
    <PackAsTool>true</PackAsTool>
    <PackageType>McpServer</PackageType>
    <IsPackable>true</IsPackable>
    
    <!-- Set recommended package metadata -->
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <PackageId>MicroAgents.McpFederationGateway</PackageId>
    <PackageVersion>0.1.0-preview</PackageVersion>
    <PackageTags>AI; MCP; server; stdio; gateway; federation; aggregator</PackageTags>
    <Description>MicroAgents MCP Federation Gateway - A reverse proxy and aggregator for MCP servers.</Description>
    
    <!-- Authors and Company -->
    <Authors>Igor Solomatov</Authors>
    <Company>Igor Solomatov</Company>
    <Product>MicroAgents MCP Federation Gateway</Product>
    <Copyright>Copyright Â© 2025 Igor Solomatov</Copyright>
    
    <!-- License -->
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    
    <!-- Repository and Project URLs -->
    <PackageProjectUrl>https://github.com/MicroAgentsNet/McpFederationGateway</PackageProjectUrl>
    <RepositoryUrl>https://github.com/MicroAgentsNet/McpFederationGateway</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
  </PropertyGroup>

  <!-- Include additional files for browsing the MCP server. -->
  <ItemGroup>
    <None Include=".mcp\server.json" Pack="true" PackagePath="/.mcp/" />
    <None Include="..\..\README.md" Pack="true" PackagePath="/" Link="README.md" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="ModelContextProtocol" Version="0.5.0-preview.1" />
    <PackageReference Include="ModelContextProtocol.AspNetCore" Version="0.5.0-preview.1" />
    <PackageReference Include="Serilog.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="6.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="6.0.0" />
  </ItemGroup>

</Project>
</file>

<file path="Program.cs">
using McpFederationGateway;
using McpFederationGateway.Interfaces;
using McpFederationGateway.Services;
using ModelContextProtocol;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Linq;

using Serilog;

var builder = WebApplication.CreateSlimBuilder(args);

// Configure Serilog
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .WriteTo.Console(standardErrorFromLevel: Serilog.Events.LogEventLevel.Verbose)
    .WriteTo.File("/Users/igor/Sources/MicroAgentsNet/logs/gateway.log", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.TypeInfoResolverChain.Insert(0, SourceGenerationContext.Default);
});

// Use Serilog for logging
builder.Services.AddLogging(loggingBuilder =>
{
    loggingBuilder.ClearProviders();
    loggingBuilder.AddSerilog(dispose: true);
});

// Register custom services
builder.Services.AddSingleton<IConfigurationService, ConfigurationService>();
builder.Services.AddSingleton<IMcpClientFactory, McpClientFactory>();
builder.Services.AddSingleton<IAggregationService, AggregationService>();

// Chat and Routing (Scoped because they depend on the session's McpServer for Sampling)
builder.Services.AddScoped<IMicroAgentChatClient, SamplingMicroAgentChatClient>();
builder.Services.AddScoped<IRouterService, RouterService>();

var mcpBuilder = builder.Services.AddMcpServer(options => 
{
    options.ServerInfo = new Implementation 
    { 
        Name = "McpFederationGateway", 
        Version = "1.0.0" 
    };
})
.WithListToolsHandler(async (context, ct) =>
{
    var aggregator = context.Services!.GetRequiredService<IAggregationService>();
    var tools = await aggregator.GetToolsAsync();
    return new ListToolsResult { Tools = tools.ToList() };
})
.WithCallToolHandler(async (context, ct) =>
{
    var router = context.Services!.GetRequiredService<IRouterService>();
    var request = context.Params!;
    var args = request.Arguments?.ToDictionary(kvp => kvp.Key, kvp => (object?)kvp.Value) ?? new Dictionary<string, object?>();
    return await router.CallToolAsync(request.Name, args, ct);
});

bool isStdio = args.Contains("--transport") && args[args.ToList().IndexOf("--transport") + 1].ToLower() == "stdio";

if (isStdio)
{
    mcpBuilder.WithStdioServerTransport();
}
else
{
    mcpBuilder.WithHttpTransport();
}

var app = builder.Build();

if (!isStdio)
{
    app.MapMcp();
}

await app.RunAsync();
</file>

<file path="SourceGenerationContext.cs">
using System.Text.Json.Serialization;
using McpFederationGateway.Models;

namespace McpFederationGateway;

[JsonSerializable(typeof(GatewayConfig))]
[JsonSerializable(typeof(McpServerConfig))]
internal partial class SourceGenerationContext : JsonSerializerContext
{
}
</file>

</files>
